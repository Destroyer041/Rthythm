<p>КИЇВСЬКИЙ МІЖНАРОДНИЙ УНІВЕРСИТЕТ
    Факультет інформаційних технологій
    Кафедра комп’ютерних наук
    
    
    Василенко Антон Сергійович
    
    
    До захисту допускаю 
    Завідувач кафедри КН
    
                     ПІБ
    (підпис)
    
    « 	 » 				 20 	  р.
    (дата)
    
    
    
    ЗАСТОСУВАННЯ ШТУЧНОГО ІНТЕЛЕКТУ В ПРОЦЕСІ СТВОРЕННЯ АНТИВІРУСНИХ СИСТЕМ
    
    
    Спеціальність: 122 – Комп’ютерні науки та інформаційні технології
    Науковий керівник: зав. кафедри комп’ютерних наук, к.т.н. проф.
    ______________________ ПІБ
    (підпис)
    
    Випускна кваліфікаційна робота допущена до захисту рішенням кафедри комп’ютерних наук протокол
    № _____ від «___» ___________ 20__ р.
    
    
    Керівник програми, декан ФІТ, доц. кафедри комп’ютерних наук
    С.В. Сініченко
    
    ____________ «___» _________ 20__ р.
    (підпис)
    
    
    
    Київ – 2023
    Реєстраційний №				
    (дата)	(П.І.Б.) 
    
    
    
    Результати перевірки
    до захисту				
    (дата)	(П.І.Б.) 
    
        
    (на доопрацювання)
    
    
    
    Результати захисту: 	
    (оцінка)
    
    
    
    Голова ЕК 				
    (підпис)	(П.І.Б.)
    
    Члени ЕК 				
    (підпис)	(П.І.Б.)
                    
    (підпис)	(П.І.Б.)
                    
    (підпис)	(П.І.Б.)
                    
    (підпис)	(П.І.Б.)
                    
    (підпис)	(П.І.Б.)
    
    
    
    
    Відповідальний 
    секретар ЕК 				
    (підпис)	(П.І.Б.)
    
     
    КИЇВСЬКИЙ МІЖНАРОДНИЙ УНІВЕРСИТЕТ
    Спеціальність: 122 – Комп’ютерні науки та інформаційні технології
    
    ЗАТВЕРДЖУЮ
    Зав. кафедри комп’ютерних наук
    ________________ ПІБ
    «____» _____________20___ року
    
    Завдання для виконання випускної кваліфікаційної роботи
        студенту Василенку Антону Сергійовичу	
    (прізвище, ім’я, по батькові)
    
    1. Тема випускної кваліфікаційної роботи «Застосування штучного інтелекту в процесі створення антивірусних систем» затверджена наказом № _________ від «______» ________________ 20__ р.
    
    2. Випускна кваліфікаційна робота виконується на матеріалах, які зібрані протягом переддипломної практики.	
    
    3. План роботи та терміни виконання розділів
    Назва розділів випускної кваліфікаційної роботи	Терміни виконання
    Вступ. Розділ І	«____»________________ 20___р.
    Розділ ІІ	«____»________________ 20___р.
    Розділ III	«____»________________ 20___р.
    Висновки	«____»________________ 20___р.
    Допрацювання роботи з урахуванням зауважень керівника	«____»________________ 20___р.
    
    4. Перелік графічного матеріалу (таблиці, схеми): блок-схеми роботи деяких прикладних методів й алгоритмів машинного навчання.	
    
    5. Термін здачі роботи на рецензію керівнику «____» ____________ 20___ р.
    
    6. Термін повного завершення, оформлення і подання на кафедру випускної кваліфікаційної роботи на захист «____» ____________ 20___ р.
    
    Завдання видав
    керівник 				
    (підпис)	(дата)
    
    Завдання отримав 
    студент 				
    (підпис)	(дата)
     
    ЗМІСТ
    ВСТУП	6
    РОЗДІЛ 1. Штучний інтелект. Сучасні методи, тенденції розвитку, практичне застосування	8
    1.1.	Поняття штучного інтелекту, основні галузі застосування	8
    1.2.	Штучний інтелект на основні його методи	8
    1.2.1.	Еволюційні алгоритми	10
    1.2.2.	Нейронні мережі: структура	10
    1.2.3.	Нейронні мережі: навчання	12
    1.3.	Навчання без контролю	14
    1.4.	Навчання з підкріпленням	15
    1.5.	Автоматична диференціація та градієнтна оптимізація	17
    Висновки до першого розділу	17
    Розділ 2. Основні математичні методи машинного навчання і штучного інтелекту в задачах побудови систем захисту інформації	18
    2.1.	Ансамбль «Дерево рішень» у машинному навчанні.	18
    2.2.	Хешування подібності (хешування з урахуванням місцевості)	19
    2.3.	Поведінкова модель	20
    2.4.	Кластеризація вхідного потоку	21
    2.5.	Великомасштабні моделі класифікації	22
    2.6.	Безпека машинного навчання	22
    Висновки до другого розділу	32
    РОЗДІЛ 3. Основі задачі штучного інтелекту в завданнях розроблення прикладних систем захисту інформації	33
    3.1.	Модуль виявлення зловмисного програмного забезпечення	33
    3.1.1.	Сучасне антивірусне програмне забезпечення	34
    3.1.2.	Підхід при розробці модуля з використанням штучного інтелекту і машинного навчання	35
    3.1.3.	Портативний виконуваний файл (PE)	37
    3.2.	Методи тестування антивірусного програмного забезпечення	38
    3.2.1.	Статичне тестування	39
    3.2.2.	Динамічне тестування	39
    3.2.3.	Тестування швидкості реакції	40
    3.2.4.	Ретроспективне тестування	41
    3.2.5.	Тестування антивірусів від labs	41
    3.2.6.	Тестування антивірусів за допомогою вірусного бюлетеня	41
    3.3.	Важливість тестування антивірусів	42
    3.4.	Розроблення системи запобігання атак на основі аналізу мережевого трафіку при роботі з операційною системою	45
    3.4.1.	Математичні основи представлення результатів	46
    3.4.2.	Логічні змінні, які беруть участь в аналізі даних трафіку	47
    3.4.3.	Опис інтерфейсу розробленої системи IDS	47
    Висновки до третього розділу	57
    ВИСНОВКИ	58
    СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ	59
    
    
    
    
    
     
    ВСТУП
    В останні роки стає дуже важливим протистояти небезпекам, яких не виявлено. Щоб передбачити рівень захисту програмного забезпечення від вірусів, які ще не випущені, слід використовувати певні методи тестування. Класичні випробування не дуже допоможуть, оскільки всі вони спрямовані на те, щоб протистояти небезпекам, які раніше були знайдені кимось іншим. З одного боку, можна повністю вимкнути базову сигнатуру в тестованому продукті та проаналізувати, як він міг знаходити шкідливі компоненти з сучасного списку «In The Wild». Але слід зазначити, що такий спосіб не допоможе отримати необхідний результат: природа будь-якого антивіруса вимагає роботи разом з базою сигнатур. Захисний компонент з вимкненими базами такого типу – це зовсім інший продукт, який не потребує тестування. Звичайно, можна також перевірити здатність антивіруса знаходити майбутні випуски вірусів, тестуючи поточну вірусну базу, але тільки у випадку тестування антивіруса з сигнатурною базою, термін якого становить не менше шести місяців. Антивірусна складова має протистояти небезпекам, яких ще не існує у всесвітній мережі. 
    Об’єктом дослідження є сучасні методи й алгоритми штучного інтелекту і машинного навчання в науці й техніці.
    Предметом дослідження є застосування основних методів штучного інтелекту для дослідження ефективності роботи антивірусних систем.
    Мета роботи. Метою роботи є аналіз сучасних прикладних методів машинного навчання, які активно використовуються для створення й аналізу антивірусних систем.
    Завдання дослідження. Основним завданням дослідження штучного інтелекту в антивірусних системах передбачають такі етапи:
        провести аналіз сучасних методів й алгоритмів, тенденції розвитку, практичного застосування штучного інтелекту загалом;
        розглянути нейронні мережі, їх особливості та реалізація;
        провести дослідженняз вчителем на без нього
        проаналізувати поведінкові моделі, їх використання у процесі дослідження антивірусних систем;
        методи класифікації та кластеризації даних за ознаками;
        ознайомитися з безпекою машинного навчання
        розглянути основі задачі штучного інтелекту в завданнях розроблення прикладних систем захисту інформації;
        провести тестування антивірусних систем;
        розроблення системи запобігання атак на основі аналізу мережевого трафіку при роботі з операційною системою.
    Структура роботи. Робота складається зі вступу, трьох розділів, які відображають основні результати досліджень у даній дипломній роботі, висновків та списку використаних джерел, які налічують 10 посилань. Загальний обсяг роботи: 59 сторінок друкованого тексту.
    
     
    РОЗДІЛ 1. Штучний інтелект. Сучасні методи, тенденції розвитку, практичне застосування
        Поняття штучного інтелекту, основні галузі застосування
    Штучний інтелект (ШІ) – це область науки і техніки, яка займається створенням комп'ютерних систем, здатних виконувати завдання, які потребують інтелектуальних здібностей людини. Ці системи можуть сприймати довкілля, аналізувати дані, приймати рішення та взаємодіяти з людьми та іншими системами.
    ШІ має безліч додатків у різних галузях науки та техніки, таких як медицина, виробництво, фінанси, транспорт, енергетика і т.д. Наприклад, у медицині ШІ може використовуватися для діагностики захворювань, прогнозування та лікування, а також для аналізу великих обсягів медичних даних. У виробництві ШІ може застосовуватися для автоматизації виробничих процесів та оптимізації їх ефективності, а також для виявлення дефектів та покращення якості продукції. У фінансовій сфері ШІ може використовуватися для аналізу ринку, прогнозування цін на акції та валюту, а також для управління ризиками. У транспортній галузі ШІ може застосовуватися для керування автономними транспортними засобами, оптимізації маршрутів та скорочення витрат на паливо. ШІ також знаходить застосування в науці, наприклад, для обробки та аналізу наукових даних, прогнозування погоди, аналізу геномів та багатьох інших галузей. 
    Однак, з розвитком ШІ виникають також питання етики та безпеки, наприклад у зв’язку з можливістю автономних систем приймати рішення, які можуть вплинути на життя та здоров'я людей. Тому необхідно приділити належну увагу розробці етичних та правових норм, які забезпечать безпеку та відповідальність у використанні ШІ.
    
        Штучний інтелект на основні його методи
    Сфери машинного навчання [1–3] і квантових технологій [4–7] мають багато спільного: обидві починалися з дивовижного бачення програм (у 1950-х роках) і 1980-х, відповідно), пройшли через низку викликів і наразі є надзвичайно актуальними темами дослідження.
    З цих двох машинне навчання міцно закріпилося за межі академії та за межі прототипів, викликаючи a революція в технологічних додатках у минулому десятиліття. Йтиметься про цю перспективну статтю висвітлення того, як працюють методи класичного машинного навчання (ML) і штучного інтелекту (AI) великі перспективи для вдосконалення квантових технологій у майбутнє. При цьому було розроблено широкий спектр ідей взаємодія між двома галузями протягом останніх п’яти років, див. рис. 1.1. Якщо хтось намагається зрозуміти квант стан за допомогою вимірювань, знайти оптимальний зворотний зв'язок стратегії або протоколи квантової корекції помилок, або проектувати нові квантові експерименти, машинне навчання може дає ефективні рішення, оптимізовану продуктивність і, в найкращі випадки, навіть нові ідеї.
     
    Рис. 1.1. Огляд завдань у сфері квантових технологій, які можуть допомогти вирішити машинне навчання та штучний інтелект краще, як пояснюється в цій перспективній статті
    
    Часто сучасні методи глибокого навчання можуть значно перевершувати досить прості методи, якщо застосовувати їх до неправильного завдання, як це видно в інших областях [8]. Ось це має вирішальне значення для аналізу обсягу проблеми та вибору найкраще підходящих алгоритмів. 
    Крім того, є кілька оглядів за останні роки з дещо іншою спрямованістю, ніж наша, напр. про машинне навчання, застосоване до фізики загалом або машинне навчання для квантової фізики багатьох тіл.
    Слід зауважити, що існує ціла сфера квантового машинного навчання, яка намагається виявити потенційні квантові переваги при реалізації нових алгоритмів навчання на квантових платформах. Сюди також входять варіаційні квантові схеми, які є дуже перспективними в контексті квантових комп’ютерів проміжного масштабу (NISQ).
    У наступному розділі буде коротко ознайомлено з основами нейронних мереж та інших методів машинного навчання, щоб підготувати основу для подальших обговорень. Основна частина нашого огляду міститься в розділі III, де описані різні застосування машини навчання. У кожному випадку слід зазначити деякі виклики та потенційні майбутні напрямки досліджень. Метою цього розділу є лише уявлення про основні основи, щоб подальше обговорення програм стало зрозумілим для читача без попереднього ознайомлення. Методи машинного навчання існують уже кілька десятиліть і включають багато ефективних підходів, що передували недавній революції глибокого навчання, наприклад «машини опорних векторів» або «дерева рішень». Однак гнучкість нейронних мереж зробила їх популярним вибором загального призначення, тому зосередимося на них.
    
        Еволюційні алгоритми
    Одним із наборів алгоритмів, які часто використовуються в задачах оптимізації в області штучного інтелекту, є еволюційні (генетичні) алгоритми. Тут ідея полягає в тому, щоб мати справу з набором варіантів рішень, кожне з яких описано за допомогою відповідного вектора. Ці рішення можуть бути випадковим чином змінені («мутовані»), два рішення можуть бути об’єднати для формування нового кандидата («кросовер»), і, нарешті, лише найкращі рішення можна зберегти для наступного раунду еволюції («відбір»). Такі методи можуть бути напрочуд ефективними, і їх застосування до нових проблем часто є простим.
    
        Нейронні мережі: структура
    Структура штучних нейронних мереж, які можна навчити апроксимувати довільні функції, слабко мотивована нейронами в мозку людини. Кожен нейрон отримує кілька вхідних даних і генерує вихідний сигнал, який служить вхідним сигналом для інших нейронів. Під час навчання сила зв'язків між нейронами змінюється.
    Точніше кажучи, кожен штучний нейрон отримує N входів xj, які підсумовуються відповідно до деяких вагових коефіцієнтів wj, що представляють силу з’єднання, див. рис. 1.2a. Після додавання зміщення (зсуву) b застосовується проста нелінійна «функція активації» f, щоб отримати результат:
    y=f(z),z=∑_(j=1)^N▒〖w_j x_j 〗+b.
    (1.1)
    
    
     
    
    Рис. 1.2. Основи нейронних мереж і машинного навчання Техніки. (а) Робота одного штучного нейрона. (б) Структура нейронної мережі з щільними шарами. (c) Еволюція параметрів мережі θ у ландшафті функції вартості з використанням стохастичного градієнтного спуску. Для кожного кроку (помаранчеві стрілки) градієнти функції усередненої вартості з відносно θ (сіра пунктирна лінія) апроксимуються за допомогою градієнт, усереднений для випадкової партії. Параметри ˆθ мінімізувати функцію усереднених витрат. (d) Класифікація немаркованих даних. (e) Змодельована проблема навчання з підкріпленням як марківський процес прийняття рішень
    
    Кілька з’єднаних нейронів утворюють нейронну мережу, як показано на рис. 1.2b. Ці мережі, як правило, структуровані в кілька рівнів, де вихідні дані кожного рівня служать входом для наступного рівня. Загалом існує один вхідний шар, один або кілька проміжних «прихованих» шарів і вихідний рівень. Вхідні дані, які подаються в таку мережу, можуть бути, напр. g. піксельні дані із зображення, і після успішного навчання вихідні нейрони кодують e. g. категорія зображення (кішка проти собаки). Мережа лише з одним прихованим шаром і достатньою кількістю нейронів вже здатна апроксимувати довільні функції з довільною точністю. Проте мережі з більшою кількістю прихованих шарів (так звані «глибокими» нейронними мережами) можуть виконувати те саме завдання з меншою кількістю нейронів.
    У мережі на рис. 1.2b усі виходи одного шару служать входом для всіх нейронів наступного шару. Така структура називається щільним шаром, або «повністю зв’язаною мережею».
    Однак це часто не найкращий вибір, особливо коли вхідні дані мають певну симетрію. Наприклад, завдання класифікації зображення може мати трансляційну симетрію, оскільки категорія об’єкта, зображеного на зображенні, не залежить від точного розташування об’єкта. Згорткові нейронні мережі (CNN) використовують цю трансляційну інваріантність, згортаючи вхідні дані за допомогою «ядра», яке можна вивчити.
    Часові ряди мають часову структуру, яку можна використовувати за допомогою так званих «рекурентних» нейронних мереж (RNN). Ключова ідея полягає в тому, що RNN отримує інформацію для кожного наступного тимчасового кроку послідовно як вхідні дані, але також зберігає деяку пам’ять про попередні вхідні дані. Одними з найдосконаліших і широко використовуваних RNN є так звані мережі довготривалої короткочасної пам’яті (LSTM).
    
        Нейронні мережі: навчання
    Можна створити мережу для наближення будь-якої функції
    шляхом належного вибору його вагових коефіцієнтів і зміщень, які часто позначаються як вектор параметрів θ. Щоб створити правильні прогнози за допомогою нейронної мережі, її параметри потрібно навчити для даної проблеми. Контрольоване навчання (SL) — це метод навчання для вивчення бажаної цільової функції f(x) із набору даних, що містить пари ("зразки") вхідних і пов’язаних виходів (x, f(x)). Нейронна мережа представляє приблизне відношення вхід-вихід fθ(x). Відхилення між прогнозом мережі та правильним результатом у наборі даних кількісно визначається функцією «вартість» (або «втрата»). Для будь-якого заданого вхідного параметра x цю функцію вартості можна обчислити, C(f_θ (x),f(x)), і зрештою її буде усереднено для всіх вибірок у наборі даних. Тренувані параметри θ в f_θ (x) повинні бути обрані таким чином, щоб мінімізувати цю (усереднену за вибіркою) функцію вартості.
    Вибір функції витрат залежить від задачі.
    Типовими сферами застосування нейронних мереж є завдання регресії та класифікації. Для регресії цільова функція f(x) є неперервною функцією вхідного значення x.
    Тоді так звана «середньоквадратична помилка» є канонічним вибором, який для n вихідних нейронів читається:
    
    C_MSE (x)=∑_(i=1)^n▒(f_(θ,i) (x)-f_i (x))^2 .	(1.2)
    
    З іншого боку, у завданнях класифікації вхідні дані слід призначити певним попередньо визначеним класам (наприклад, категоріям зображень). Це вирішується тим, що кожен вихідний нейрон відповідає одному з n класів. Кожне значення нейрона (або «активація») може бути інтерпретовано як ймовірність того, що вхідний сигнал буде призначено відповідному класу. У такій ситуації типовою функцією витрат є так звана «перехресна ентропія», засіб для порівняння розподілу ймовірностей.
    У будь-якому випадку навчання нейронної мережі ґрунтується на мінімізації функції вартості за допомогою градієнтного спуску.
    Однак оцінка функції вартості, усередненої за всіма вибірками набору даних, є неможливою. Навпаки, на кожному кроці оновлення функція вартості усереднюється за пакетом випадково вибраних вхідних даних. У найпростішому варіанті результуючої схеми «стохастичного градієнтного спуску» (див. рис. 1.2c) параметри θ оновлюються на кожному кроці відповідно до θ → θ − ηg з відповідним градієнтом g:
    g=(∂〈C〉_batch)/∂θ.	(1.3)
    〈⋅〉_batch позначає середнє значення для випадкової партії, а η — «швидкість навчання», що контролює розмір оновлення.
    Нейронна мережа має багато параметрів (навіть маленькі мережі зазвичай мають тисячі параметрів, найбільші опубліковані мережі мають сотні мільярдів параметрів). Тому вкрай важливо, щоб існував високоефективний підхід до розрахунку градієнта: так звана схема «зворотного поширення». Як випливає з назви, цей алгоритм обчислює градієнти шар за шаром, починаючи з вихідного шару. Примітно, що це обчислювально не є більш вимогливим, ніж початкове оцінювання нейронної мережі (також називається прямим розповсюдженням). Значним апаратним прогресом для навчання нейронних мереж є GPU (графічні процесори), оптимізовані для виконання високоефективних маніпуляцій великими матрицями. Ця ефективність є важливою для успіху ML у багатьох програмах.
    
        Навчання без контролю
    Підходи до неконтрольованого навчання можуть самостійно вивчати структуру немаркованих наборів даних, наприклад, як показано на рис. 1.2d. Типовими сферами застосування є вивчення функцій, коли машину просять знайти компактне представлення даних, і кластеризацію, де комп’ютер має сортувати власні зразки в класи зі схожими властивостями. Генеративні моделі також часто відносять до сфери неконтрольованого навчання. Їх мета полягає в стохастичному створенні нових зразків, які мають такий самий розподіл, що й раніше спостережуваний набір даних (наприклад, зображення того самого типу, хоча ніколи раніше не зустрічалися). Найпростіші підходи до вивчення особливостей все ще покладаються на методи навчання під наглядом (а саме, «самоконтрольоване» навчання в так званих «автокодувальниках»).
    Однак моделі кластеризації та генеративні моделі зазвичай реалізуються з використанням різних методів.
    
        Навчання з підкріпленням
    Деякі з найважливіших проблем у штучному інтелекті та машинному навчанні можна розглядати як спробу знайти оптимальну стратегію для вирішення певного завдання, де оптимальна стратегія невідома (отже, контрольоване навчання не може бути застосоване). Це область навчання з підкріпленням (RL), яка спрямована на виявлення оптимальної послідовності дій у проблемах прийняття рішень.
    Його потужність була добре проілюстрована в настільних іграх, таких як шахи або відеоіграх, у всіх з яких RL здатний досягти надлюдської продуктивності. У багатьох додатках RL може знайти оптимальну стратегію без попередніх знань про фактичну динаміку системи. Коли це так, говоримо про «безмодельний» RL. Ціль у будь-якому завданні RL кодується шляхом вибору відповідної «винагороди», величини, яка вимірює, наскільки добре було вирішено завдання.
    Типову проблему RL можна зрозуміти як так званий «Марковський процес прийняття рішень» (MDP), див. рис. 1.2e. MDP складається з «агента» (контролера) і «оточення» (світу або системи, якою потрібно керувати), і обидва взаємодіють у кілька часових кроків. На кожному кроці часу t спостерігається стан середовища st. Виключно на основі цього спостереження агент приймає рішення про свою наступну дію, яка змінить стан середовища. Поведінка агента визначається «політикою» π(a|s), яка позначає ймовірність вибору дії при заданому спостереженні s. За кожну дію at агент отримує винагороду rt. Наприклад, у грі ця винагорода може бути +1/ − 1 на останньому часовому кроці, коли агент виграв/програв гру, або 0 на всіх попередніх кроках. RL має на меті максимізувати кумулятивну винагороду R (також називається «повернення»)
    R=∑_(t=1)^T▒r_t ,	(1.4)
    де T – загальна кількість кроків у часі.
    Існує три основні гілки алгоритмів RL: градієнт політики, Q-навчання та методи акторської критики. Для методів градієнта політики агент безпосередньо встановлює політику πθ(a|s). У глибокому RL цей агент реалізується глибокою нейронною мережею з параметрами θ, які можна навчити. Щоб знайти оптимальну стратегію, policy-gradient оцінює градієнт середньої прибутковості hRi відносно θ. Тут h·i позначає середнє за всіма траєкторіями для поточної політики. На перший погляд незрозуміло, як провести градієнти через винагороду, не знаючи моделі.
    Однак можна обчислити градієнти частоти певної винагороди за допомогою функції політики πθ. Таким чином, градієнт виходить:
    g=∂〈R〉/∂θ=〈R∑_(t=1)^T▒〖∂/∂θ  ln⁡〖π_theta (a_t |s_t )〗 〗〉.	(1.5)
    Важливо відзначити, що R залежить від повної траєкторії та параметрів θ (ми придушили ці залежності для стислості). Оновлення на основі цього рівняння збільшать («підсилюють») ймовірність дій, які відбуваються переважно на траєкторіях високої винагороди. Іншим підходом до пошуку оптимальної політики є так зване «Qlearning». Він використовує «функцію Q» Qπ(s, a), яка намагається оцінити якість дії a: вона визначається як середній очікуваний майбутній прибуток, починаючи зі стану s і дії a для політики π. Оптимальна політика тоді, за визначенням, полягає у виборі дії, яка максимізує Q у даному стані s. На практиці функція Q спочатку невідома. Під час навчання вивчається наближення до цієї функції, часто використовуючи глибоку нейронну мережу для представлення Q.
    Нарешті, третя група алгоритмів RL – це так звані методи «актор-критика». Вони намагаються поєднати переваги як підходів на основі градієнта політики, так і підходів Q-навчання. Основна ідея методів акторської критики полягає в оцінці очікуваної винагороди за поточним станом, так званої функції цінності V . Успіх будь-якої дії потім вимірюється шляхом порівняння отриманої винагороди з V . Як і слід було очікувати, функція цінності представлена нейронною мережею («критична» мережа), яка навчена SL наближати функцію справжньої вартості для поточної політики.
    
        Автоматична диференціація та градієнтна оптимізація
    Глибоке навчання є ефективним завдяки техніці зворотного поширення, яка може ефективно обчислювати градієнти щодо всіх сотень або мільйонів параметрів нейронної мережі. Цей прийом у більш загальному вигляді веде до концепції автоматичної диференціації. там, ідея полягає в тому, щоб отримати точний градієнт по відношенню до будь-якої змінної, що з’являється в будь-якому вигляді числового обчислення. Як числовий підхід, це відрізняється від символічного диференціювання, що застосовується в програмах комп’ютерної алгебри. Сучасні фреймворки, що використовуються для нейронних мереж, пропонують різні режими автоматичного розрізнення. Це дає можливість використовувати їх для довільних завдань безперервної оптимізації на основі градієнта, особливо тих, що включають багато параметрів, де ефективність є проблемою.
    
    Висновки до першого розділу
    У ході вивчення предметної галузі застосування штучного інтелекту було визначено основні напрямки використання ШІ, були досліджені математичні методи, які використовуються в аналізі даних, оптимізації, керування об1єктами на основі машинного навчання та штучного інтелекту. Також було досліджено основні переваги й недоліки основних методів й алгоритмів штучного інтелекту у процесі їх адаптації до конкретних науково-прикладних завдань.
     
    РОЗДІЛ 2. Основні математичні методи машинного навчання і штучного інтелекту в задачах побудови систем захисту інформації
        Ансамбль «Дерево рішень» у машинному навчанні.
    У конкретному випадку контрольованого навчання для захисту від зловмисного програмного забезпечення завдання може бути сформульовано так: задано набір характеристик об’єкта X і відповідні мітки об’єкта Y як вхідні дані, створіть модель, яка вироблятиме правильні мітки Y' для раніше невидимих тестові об'єкти X'. X може бути деякими функціями, що представляють вміст або поведінку файлу (статистика файлів, список використаних функцій API тощо), а мітки Y можуть бути просто «зловмисним програмним забезпеченням» або «доброякісним» (у більш складних випадках нас може зацікавити штраф-зерниста класифікація, наприклад віруси, трояни-завантажувачі, рекламні програми тощо). У разі неконтрольованого навчання, більше зацікавлені у виявленні прихованої структури даних, наприклад, пошуку груп подібних об’єктів або сильно корельованих ознак.
    Багаторівневий захист наступного покоління від «Лабораторії Касперського» широко використовує методи машинного навчання на всіх етапах конвеєра виявлення – від методів масштабованої кластеризації, що використовуються для попередньої обробки вхідного потоку файлів в інфраструктурі, до надійних і компактних моделей глибокої нейронної мережі для виявлення поведінки, які працюватимуть безпосередньо на користувачах. Такі технології розроблено таким чином, щоб задовольнити кілька важливих вимог до моделей машинного навчання в додатках інформаційної безпеки в реальному світі, тобто надзвичайно низький рівень помилкових спрацьовувань, можливість інтерпретації моделі та стійкість до потенційного противника.
    Розглянемо деякі з найважливіших технологій машинного навчання, які використовуються в кінцевих продуктах Лабораторії Касперського:
    У цьому підході прогностична модель набуває форми набору дерев рішень (наприклад, випадкового лісу або дерев із посиленням градієнта). Кожен нелистовий вузол дерева містить певне запитання щодо особливостей файлу, тоді як листові вузли містять остаточне рішення дерева щодо об’єкта. Під час тестової фази модель проходить дерево, відповідаючи на запитання у вузлах із відповідними характеристиками об’єкта, що розглядається. На завершальному етапі рішення кількох дерев усереднюються за допомогою певного алгоритму, щоб отримати остаточне рішення щодо об’єкта. Модель має переваги етапу захисту Pre-Execution Proactive на кінцевій точці (рис. 2.1).
     
    Рис. 2.1. Модель має переваги етапу захисту Pre-Execution Proactive 
    на кінцевій точці
    Одним із наших застосувань цієї технології є Cloud ML для Android, який використовується для виявлення мобільних загроз.
    
        Хешування подібності (хешування з урахуванням місцевості)
    Хеші, використовувані для створення «слідів» зловмисного програмного забезпечення в минулі часи, були чутливі до кожної незначної зміни у файлі. Цим недоліком скористалися розробники зловмисного програмного забезпечення за допомогою методів обфускації, наприклад поліморфізму на стороні сервера: незначні зміни в зловмисному програмному забезпеченні прибрали його з радару. Хеш подібності (або геш, чутливий до локалізації) — це метод виявлення подібних шкідливих файлів. Для цього система витягує функції файлу та використовує навчання ортогональної проекції, щоб вибрати найважливіші функції. Потім застосовується стиснення на основі ML, щоб вектори значень подібних характеристик перетворювалися на схожі або ідентичні шаблони. Цей метод забезпечує гарне узагальнення та помітно зменшує розмір бази записів виявлення, оскільки один запис тепер може виявити ціле сімейство поліморфних шкідливих програм. Модель має переваги етапу захисту Pre-Execution Proactive на кінцевій точці (рис. 2.2).
     
    Він застосований у системі виявлення гешу схожості.
    
    
        Поведінкова модель
    Компонент моніторингу забезпечує журнал поведінки - послідовність системних подій, що відбулися під час виконання процесу, разом з відповідними аргументами. Щоб виявити зловмисну активність у спостережуваних даних журналу, наша модель стискає отриману послідовність подій до набору двійкових векторів і навчає глибоку нейронну мережу розрізняти чисті та шкідливі журнали.
    Класифікація об’єктів, створена за поведінковою моделлю, використовується як статичними, так і динамічними модулями виявлення в продуктах Kaspersky на стороні кінцевої точки (рис. 2.3).
     
    Рис. 2.3. Класифікація об’єктів модулями виявлення в продуктах Kaspersky
    
    Машинне навчання відіграє не менш важливу роль, коли йдеться про створення належної внутрішньолабораторної інфраструктури обробки зловмисного програмного забезпечення.
    
        Кластеризація вхідного потоку
    Алгоритми кластеризації на основі ML дозволяють нам ефективно розділяти великі обсяги невідомих файлів, які надходять до нашої інфраструктури, на розумну кількість кластерів, деякі з яких можуть бути автоматично оброблені на основі присутності в них уже анотованого об’єкта (рис. 2.4).
     
    Рис. 2.4. Алгоритми кластеризації на основі ML
        Великомасштабні моделі класифікації
    Деякі з найпотужніших моделей класифікації (наприклад, величезний ліс випадкових рішень) потребують великої кількості ресурсів (процесорний час, пам’ять) разом із дорогими екстракторами функцій (наприклад, обробка через пісочницю може знадобитися для детальних журналів поведінки). Тому ефективніше зберігати та запускати моделі в лабораторії, а потім дистиллювати знання, отримані такими моделями, шляхом навчання деякої полегшеної моделі класифікації на вихідних рішеннях більшої моделі.
    
        Безпека машинного навчання
    Алгоритми ML, виведені з меж лабораторії та введені в реальний світ, можуть бути вразливими до багатьох форм атак, спрямованих на те, щоб змусити системи ML робити навмисні помилки. Зловмисник може отруїти навчальний набір даних або перепроектувати код моделі. Крім того, хакери можуть «переборити» моделі ML за допомогою спеціально розробленого «змагального штучного інтелекту», щоб автоматично генерувати багато зразків атак, доки не буде виявлено слабке місце моделі. Вплив таких атак на системи захисту від зловмисного програмного забезпечення на основі машинного навчання може бути руйнівним: помилково ідентифікований троян означає зараження мільйонів пристроїв і втрату мільйонів доларів.
    Xplico – це сучасний і потужний декодер інтернет-трафіку, інструмент криміналістичного аналізу мережевого трафіку (Network Forensic Analysis Tool – NFAT) [3]. У цій останній версії програми доданий GUI — графічний інтерфейс, який дозволяє переглядати фотографії та відео, які скине програма.
    Мета Xplico у тому, щоб витягти з перехопленого трафіку дані, які призначалися додатком.
    Наприклад, з PCAP файлу утиліта може отримувати електронну пошту (POP, IMAP та SMTP протоколи), весь контент HTTP трафіку, кожен виклик VoIP (SIP), FTP, TFTP тощо.
    Після цієї програми можу з упевненістю викинути велику кількість сніферів в топку.
    Під час декодування сеансу Xplico робить файл KML, цей файл, який використовується з Google Earth, дозволяє переглядати географічну карту з'єднань, що декодуються Xplico.
    Для початку оновимо список пакетів операційної системи для встановлення усіх необхідних програм-утиліт для повноцінної роботи Xplico.
    Для оновлення виконаємо наступну команду
    allif@allif-pc: ~$ sudo apt update
    
     
    Рис. 2.5. Виведення списку з пакетами, які необхідно оновити
    
    Наступний крок – це оновлення застарілих пакетів. Для цього виконаємо команду:
    allif@allif-pc: ~$ sudo apt upgrade
    
     
    Рис. 2.6. Оновлення застарілих пакетів перед встановлення Xplico для аналізу мережевого трафіка
     
    Рис. 2.7. Оновлення застарілих пакетів перед встановлення Xplico для аналізу мережевого трафіка (заключний етап)
    Для формування файлу з мережевим трафіком потрібно встановити середовище для його формування, наприклад, wireshark (рис. 2.8). 
     
    Рис. 2.8. Встановлення wireshark для формування перехвату
    мережевого трафіка
    
    Настройка Wireshark на Ubuntu 20.04 X64. Для виконання настройки виконаємо наступні команди, які показані нижче на рис. 2.10.
     
    Рис. 2.10. Команда для формування виконуваного файлу
    
    Таким чином, ми виконуємо перехват з-під облікового запису allif в ОС Ubuntu 20.04 x64.
    Після запуску wireshark отримуємо наступний інтерфейс (рис.6).
     
    Рис. 2.11. Головне графічне вікно wireshark з вибором джерела захоплення мережевого трафіка
    
    Наступним кроком є встановлення аналізу мережевого трафіку Xplico.
    
     
    Рис. 2.12. Отримання пакетів Xplico з офіційного джерела (вебресурсу)
    
    Отримання пакету Xplico показано нижче на рис. 2.13.
    
     
    Рис. 2.13. Отриманий програмний пакет Xplico з офіційного джерела
    
    Виконуємо встановлення отриманого пакету Xplico. 
     
    Рис. 2.14. Процес встановлення Xplico (на базі отриманого пакета) 
    на Ubuntu 20.04 x64
    
    Наступним кроком є формування самого ж мережевого трафіка з використанням wireshark з метою його передачі для подальшого аналізу програмною утилітою Xplico. 
    Спочатку переглянемо створені фільтри для захоплення трафіку.
     
    Рис. 2.15. Перегляд фільтрів перед формуванням файлу 
    з перехопленим мережевим трафіком
    
    Далі виконуємо захват мережевого трафіку протягом деякого періоду часу.
     
    Рис. 2.16. Процес перехвату трафіку за допомогою утиліти wireshark
    
    Після того, як було виконано перехват мережевого трафіку, виконаємо збереження файлу з даним трафіком у домашню теку «allif» користувача allif, для якого wireshark був настроєний.
    
     
    Рис. 2.17. Збереження перехваченого трафіка у теку користувача allif
    
    Сформований файл з перехваченим трафіком збережено у домашній теці з назвою «Trafic.pcapng».
     
    Рис. 2.18. Результат збереження перехваченого трафіка у домашню теку
    (файл Trafic.pcapng)
    
    У середовищі Xplico можна створювати варіант аналізу, який визначає точку захоплення в мережі. При підключенні до вебінтерфейсу Xplico створюємо процедуру для аналізу трафіка. 
    Створюємо нову справу, як показано нижче.
     
    Рис. 2.19. Створення нової справи для аналізу мережевого трафіка
    
    Далі натискаємо вкладку «New Session» для того, щоб створити новий сеанс. Після цього вводиться назву сеансу, щоб спростити процес сортування під час аналізу кількох сеансів.
    
     
    Рис. 2.20. Створення нової сесії для аналізу захопленого трафіка
    
     
    Рис. 2.21. Дані про поточну сесію
    
     
    Рис. 2.22. Дані аналізу URL-адреси
    
    З цієї причини до використання ML у системах безпеки слід звернути увагу на деякі ключові міркування:
        Постачальник засобів безпеки повинен розуміти та ретельно відповідати основним вимогам до продуктивності ML у реальному, потенційно ворожому світі, вимогам, які включають стійкість до потенційних супротивників. Аудити безпеки, що стосуються ML/AI, і «red-teaming» мають бути ключовим компонентом розробки ML/AI.
        Оцінюючи безпеку рішення ML, слід поставити питання про те, наскільки рішення залежить від даних і архітектури сторонніх розробників, оскільки багато атак базуються на вхідних даних третьої сторони (ми говоримо про канали аналізу загроз, публічні набори даних, попередні навчені та сторонні моделі ML).
        Методи ML не слід розглядати як «остаточну відповідь». Вони повинні бути частиною багаторівневого підходу до безпеки, де взаємодоповнюючі технології захисту та людський досвід працюють разом, стежачи один за одним.
    Для більш детального огляду популярних атак на алгоритми машинного навчання та методів захисту від цих загроз див. наш офіційний документ «ШІ під атаками: як захистити машинне навчання в системі безпеки».
    
    Висновки до другого розділу
    Для дослідження поведінкових систем активно використовують методи штучного інтелекту. Такий підхід дає можливість застосувати машинне навчання для прогнозу роботи такого роду систем.
    У даному розділі проведено аналіз основних задач, методів й алгоритмів застосування штучного інтелекту для розв’язання задач з антивірусної безпеки. Тут показано, що саме основні методи сучасного штучного інтелекту дають можливість здійснювати ефективний прогноз роботи антивірусного програного забезпечення з метою уникнення пошкодження персональних даних, які, зокрема, містяться на персональному комп’ютері користувача системи.
    
     
    РОЗДІЛ 3. Основі задачі штучного інтелекту в завданнях розроблення прикладних систем захисту інфоРмації
        Модуль виявлення зловмисного програмного забезпечення
    Зловмисне програмне забезпечення, скорочення від шкідливого програмного забезпечення, складається з програм (код, сценарії та інший вміст), призначених для порушувати роботу або збирати інформацію, що призводить до втрати конфіденційності, отримувати несанкціонований доступ до системи ресурси та іншу образливу поведінку [1]. Це загальний термін, який використовується для визначення різноманітних форм ворожого, нав'язливе або дратівливе програмне забезпечення або програмний код. Будь-яке програмне забезпечення класифікується як зловмисне на основі наміру виробник, а не будь-яка конкретна функція. Зловмисне програмне забезпечення включає комп’ютерні віруси, хробаки, троянські програми, шпигунське програмне забезпечення, нечесне рекламне програмне забезпечення, кримінальне програмне забезпечення, більшість руткітів та інше шкідливе та небажане програмне забезпечення чи програми [2].
    У 2008 році компанія Symantec опублікувала звіт про те, що «рівень випуску шкідливого коду та інших небажаних програм може перевищувати законні програмні додатки». За даними F-Secure, «стільки ж зловмисного програмного забезпечення, створеного в 2007, як і за попередні 20 років загалом». [3]. Хоча вони можуть нічого не означати для звичайного домашнього користувача, ці статистика викликає тривогу, враховуючи фінансові наслідки таких загроз для підприємств у разі таких загрози проникають у великі обсяги даних, які зберігаються та з якими здійснюються транзакції, і порушують їх.
    Шкідливе програмне забезпечення поширене у світі незліченних користувачів комп’ютерів, які постійно стикаються з цими загрозами з різних джерел, таких як Інтернет, локальні мережі та портативні накопичувачі. Зловмисне програмне забезпечення має потенційно низький або високий ризик і може призвести до неправильної роботи систем, крадіжки даних і навіть збою. Зловмисне програмне забезпечення може являти собою виконувані файли або файли системної бібліотеки у формі вірусів, хробаків, троянів, усі вони спрямовані на порушення безпеки системи та конфіденційність користувача. Як правило, антивірусне програмне забезпечення базується на системі визначення сигнатур, яка постійно оновлюється з Інтернету та таким чином відстежує відомі віруси. Хоча цього може бути достатньо для домашніх користувачів, загроза безпеці від нового вірусу може загрожувати всій корпоративній мережі.
    У цьому документі пропонується новий і більш досконалий антивірусний механізм, який може не тільки сканувати файли, але й накопичувати знання та виявляти файли як потенційні віруси. Це робиться шляхом вилучення системних викликів API, зроблених різними звичайними та шкідливими виконуваними файлами, і використанням алгоритмів машинного навчання для класифікації та, отже, ранжування файлів за шкалою ризику безпеки. Хоча така система має велику кількість процесора, вона дуже ефективна при централізованому використанні для захисту корпоративної мережі, яка, можливо, більш схильна до таких загроз
    
        Сучасне антивірусне програмне забезпечення
    Антивірусне програмне забезпечення використовується для запобігання, виявлення та видалення шкідливих програм, комп’ютерних вірусів, комп’ютерних черв’яків, троянських програм, шпигунського та рекламного ПЗ. Антивірусні механізми зазвичай використовують різні стратегії. Виявлення на основі сигнатур передбачає пошук відомих шаблонів даних у виконуваному коді. Однак комп’ютер може бути заражений новим вірусом, для якого не існує сигнатур [6]. Щоб протистояти таким загрозам «нульового дня», можна використовувати евристику, яка ідентифікує нові віруси або варіанти існуючих вірусів шляхом пошуку відомого шкідливого коду. Деякі антивіруси також можуть робити прогнози, запускаючи файли в пісочниці та аналізуючи результати.
    Часто антивірусне програмне забезпечення може погіршити роботу комп’ютера. Будь-яке неправильне рішення може призвести до порушення безпеки, оскільки воно працює на високонадійному рівні ядра операційної системи. Якщо антивірусне програмне забезпечення використовує евристичне виявлення, успіх залежить від правильної середини між помилковими позитивними та негативними результатами.
    Сьогодні зловмисне програмне забезпечення може більше не бути виконуваними файлами. Потужні макроси в Microsoft Word також можуть становити загрозу безпеці. Традиційно антивірусне програмне забезпечення значною мірою покладалося на сигнатури для виявлення шкідливих програм. Однак через нові типи зловмисного програмного забезпечення підходи на основі сигнатур більше не є ефективними [7].
    Хоча стандартний антивірус може ефективно стримувати вірусні спалахи, для великих підприємств будь-який злом може бути потенційно смертельним. Виробники вірусів використовують «олігоморфні», «поліморфні» та «метаморфічні» віруси, які шифрують свої частини або модифікують себе як метод маскування, щоб не закріплювати сигнатури вірусів у словнику [8].
    Дослідження 2017 року показали, що ефективність антивірусного програмного забезпечення різко знизилася, особливо проти невідомих атак або атак нульового дня. Рівень виявлення впав з 40-50% у 2006 році до 20-30% у 2007 році.
    Проблема значно посилюється завдяки новим методам розробників вірусів. Тестування на основних сканерах вірусів показує, що жоден не забезпечує 100% виявлення вірусів. Найкращі з них забезпечили 99,6% виявлення, тоді як найнижчі забезпечили лише 81,8% у тестах, проведених у лютому 2010 року. Усі антивірусні сканери також дають хибнопозитивні результати, ідентифікуючи безпечні файли як шкідливі програми.
    
        Підхід при розробці модуля з використанням штучного інтелекту і машинного навчання
    Очевидно, поточні методи антивірусного механізму не є оптимальними для виявлення вірусів у реальному часі. Вони можуть бути корисним для контролю вірусів, щойно вони заражають системи, що, знову ж таки, фатально для підприємств [9; 10].
    Таким чином, це дослідження спрямоване на центральне рішення, яке працює на рівні брандмауера корпоративної мережі. Повна схема системи показана на рис. 3.1, а діаграма нашого процесу показана на рис. 3.2.
    Діаграма мережі показує візуальне представлення логічної структури мережі. Вона включає в себе пристрої, такі як маршрутизатори, комутатори, сервери, клієнтські комп'ютери, а також логічні елементи, такі як IP-адреса та мережеві маски. Для створення діаграми мережі використовуються спеціальні програми, такі як Microsoft Visio, Dia, LucidChart та інші. Такого роду діаграми дозволяють проектувати та візуалізувати набір, оптимізувати її роботу та діагностувати проблеми при їх виникненні.
     
    Рис 3.1. Діаграма мережі усієї системи
    
     
    Рис. 3.2. Схема процесу системи
    
    Схема на рис. 3.2 має базовий принцип захисту.
    
        Портативний виконуваний файл (PE)
    Цей формат є форматом файлів для виконуваних файлів, об’єктного коду та бібліотек DLL, які зазвичай використовуються в операційних системах Windows [23]. Термін «портативний» означає універсальність формату в численних середовищах архітектури програмного забезпечення операційної системи. Формат PE — це, по суті, структура даних, яка інкапсулює необхідну інформацію для завантажувача ОС Windows для керування загорнутим виконуваним кодом. У першу чергу він включає динамічні бібліотечні посилання для зв’язування, таблиці експорту та імпорту API, дані керування ресурсами тощо.
    Портативний виконуваний файл складається з кількох розділів, які вказують динамічному компонувальнику відображення файлу в пам’яті. Виконуваний образ складається з кількох різних областей, кожна з яких потребує різного захисту пам’яті. Таблиця адрес імпорту (IAT) використовується для пошуку таблиць, коли програма викликає функцію в іншому модулі. Це пов’язано з тим, що скомпільована програма не розпізнає розташування в пам’яті бібліотек, від яких вона залежить, і якщо виконується виклик API, потрібен непрямий перехід. Таким чином, динамічний компонувальник завантажує модулі та об’єднує, записуючи фізичні адреси в IAT, щоб вони вказували на розташування пам’яті відповідних функцій бібліотеки.
    У дослідженні можна витягти заголовок PE із багатьох інфікованих і звичайних виконуваних файлів і за допомогою IAT витягли різні виклики API та зберегли їх у шахті даних [11; 12]. Потім отримується інформаційний приріст (IG) для кожної функції.
    Постійний розвиток цифрових комунікацій призвів до того, що кількість користувачів глобальної мережі Інтернет зросла майже в рази.
    Сьогодні, перш ніж вийти у всесвітню павутину, кожен замислюється про встановлення спеціального антивірусного програмного забезпечення.
    На ринку спеціальних утиліт і компонентів представлений широкий вибір антивірусного програмного забезпечення, яке, за словами їх розробників, є дійсно надійним, практичним і простим у використанні. Саме в цьому контексті процес тестування антивірусного програмного забезпечення та компонентів стає дуже популярним, щоб ефективно знайти найбільш підходящий веб-продукт.
    
        Методи тестування антивірусного програмного забезпечення
    Сьогодні існує 4 типи методів в області тестування програмного забезпечення та подібних продуктів:
        Статичний;
        динамічний;
        Тести швидкості реакції;
        Ретроспектива.
    Нижче наведено кожного з типів методів тестування.
    
        Статичне тестування
    Це найпростіший і найзрозуміліший спосіб перевірити працездатність антивірусного програмного забезпечення та подібних продуктів. Його сенс полягає в обов'язковому скануванні за технічним запитом, який відтворюється на основі шкідливого ПЗ.
    Щоб отримати конкретні результати від статичного тесту, тоді слід використовувати величезну колекцію шкідливих програм, структура якої містить понад тисячу файлів і подібних документів.
    У мережі можна знайти спеціальні колекції випробувальних організацій (AV-Test і AV-Comparatives), які мають більше тисячі можливих програм і файлів, що дозволяють проводити успішне тестування. Іноді його структура може налічувати до 1000 000 файлів. Звичайно, згадані тести мають свої переваги та недоліки.
    Перевагою є те, що весь процес тестування виконується на численних колекціях доступних шкідливих програм, які включають найпопулярніші типи вмісту шкідливих програм.
    Недоліком є те, що такий діапазон колекцій зазвичай включає лише «свіжі» випуски файлів шкідливих програм. Досвід показав, що великою популярністю користуються види, які живуть не більше півроку.
    Крім того, недоліком є також те, що таке тестування допомагає емулювати апаратне забезпечення за вашим запитом, тоді як насправді користувач отримує файли та елементи шкідливого ПЗ на особисту електронну пошту або безпосередньо завантажуючи з всесвітньої мережі. Дуже важливо знайти такі файли в той момент, коли вони з'явилися на персональному комп'ютері клієнта.
    
        Динамічне тестування
    Його сенс полягає у відтворенні реального середовища клієнта, в якому активно тестується необхідний продукт, що відповідає за безпеку середовища користувача, за допомогою максимально доступної кількості можливих віртуальних інструментів. Таке тестування стає все більш популярним через швидку розробку нових інструментів і методів, які неможливо повністю виконати в традиційному середовищі тестування.
    Наприклад, щоб проаналізувати поточну ефективність використовуваного антивірусного захисту, тестери PC Pro не лише відтворювали колекцію вірусів за їхнім запитом, а й безпосередньо завантажували електронні листи із зараженими файлами або емулювали завантаження «небезпечних» файлів з Інтернету на основі письмових сценаріїв.
    Такий тест можна вважати найбільш схожим на реальну ситуацію і, як з’ясувалося, можливість протистояти шкідливому програмному забезпеченню та компонентам у більшості клієнтських продуктів значно нижча, ніж кількість виявлених вірусів у момент тестування заражених документів на запит.
    
        Тестування швидкості реакції
    Незважаючи на те, що такий метод не є дуже використовуваним і популярним, такий тип тестування повинен бути детально описаний і розшифрований.
    Тестування швидкості реакції проводилося майже щодня в той час, коли всесвітня мережа страждала від «нальоту поштових хробаків». Можна навіть згадати назви таких програм – Sobig, Bagle, Mydoom, Sober.
    На відміну від статичного типу тестування, тестування швидкості реакції використовує досить невеликий набір необхідних шаблонів.
    Щоб точно визначити швидкість реакції тестованої антивірусної програми, в першу чергу зверніть увагу на швидкість знаходження останньої модифікації та збірки шкідливого вмісту. До речі, при проведенні такого тестування перевага надається тим антивірусам, бази яких найчастіше оновлюються та доповнюються новою інформацією та файлами захисту.
    
        Ретроспективне тестування
    На відміну від класичних методів і способів тестування, ретроспективне тестування проводиться для перевірки різних версій антивірусного захисту на даний момент, але в минулому.
    Зазвичай такий момент дуже далекий від дати тестування, оскільки буде розроблено максимально можливу кількість комп'ютерних вірусів, з якими потрібно працювати. Це означає, що результати ретроспективного тестування дозволяють перевірити реальний захист тестованого антивірусного програмного продукту.
    
        Тестування антивірусів від labs
    Аналізуючи результати тестування спеціалізованою лабораторією, спочатку ретельно вивчіть тестований продукт, а також його постачальника.
    Як це зазвичай буває, різні тести можуть перевіряти 2 однакові продукти, розроблені одним розробником, по-різному. Тому рекомендується комплексно вивчати технології розробника антивірусного контенту.
    Детальний звіт таких вузькоспеціалізованих лабораторій як ICSA і West Coast Labs про тестування продукту вендора завжди публікується після закінчення тестування з позитивним балом.
    Ці моменти лабораторій останнім часом починають відігравати важливу роль у процесі вибору перевіреного антивірусного ПЗ, але їх відсутність не означає, що продукт неякісний чи другосортний. Розробники просто не захотіли брати участь у процесі тестування.
    
        Тестування антивірусів за допомогою вірусного бюлетеня
    Лабораторія Virus Bulletin використовує оригінальний метод тестування працездатності антивірусних програм на основі логіки пошуку шкідливих компонентів з відомої популярної колекції WildList.
    Крім того, він перевіряє не тільки здатність утиліти знаходити вірус, але й комплексне функціонування всього програмного забезпечення, особливо його швидку реакцію та вплив на приховані небезпеки.
    Крім того, він обчислює суму фальшивих виявлень, що є дуже важливим компонентом для будь-якої антивірусної програми.
    Усі антивіруси, які успішно пройшли тестування та набрали бали від 95 до 100%, а у разі нульової фейкової відповіді отримують корпоративне право використовувати спеціальний логотип VB 100%.
    Особливістю цієї лабораторії є те, що для тестування використовується лише список шкідливих компонентів, випущений за 2-3 тижні до початку тестування (рис. 3.1). Поряд з роботою з пошуку вірусів компоненти додатково тестуються на порожніх файлах і даних, щоб показати можливість фальшивої роботи захисту.
     
    Рис. 3.1. Принципи тестування антивірусів
    
    Усі компанії, які надіслали свої програмні компоненти на тестування, не знають, чи пройде їх продукт успішно чи ні.
    
        Важливість тестування антивірусів
    В останні роки стає дуже важливим протистояти небезпекам, яких не виявлено. Щоб передбачити рівень захисту програмного забезпечення від вірусів, які ще не випущені, слід використовувати певні методи тестування. Класичні випробування не дуже допоможуть, оскільки всі вони спрямовані на те, щоб протистояти небезпекам, які раніше були знайдені кимось іншим.
    З одного боку, можна повністю вимкнути базову сигнатуру в тестованому продукті та проаналізувати, як він міг знаходити шкідливі компоненти з сучасного списку «In The Wild».
    Але слід зазначити, що такий спосіб не допоможе отримати необхідний результат: природа будь-якого антивіруса вимагає роботи разом з базою сигнатур.
    Захисний компонент з вимкненими базами такого типу – це зовсім інший продукт, який не потребує тестування.
    Звичайно, можна перевірити здатність антивірусу знаходити майбутні випуски вірусів, тестуючи поточну вірусну базу, але тільки у випадку тестування антивіруса з сигнатурною базою, термін якого становить не менше шести місяців.
    Логічно припустити, що вірусів, які зараз є в списку ITW, не існувало півроку-рік тому. Антивірусна складова має протистояти небезпекам, яких ще не існує у всесвітній мережі.
    До речі, таке тестування проводить спеціалізований ресурс av-comparatives.com, де кожен користувач може ознайомитися з результатами ретроспективного тестування, які допомагають вибрати найбільш підходящий антивірус, а також допоможуть прослідкувати тенденцію розвитку програм захисту (рис. 3.2).
     
    Рис. 3.2. Логіка перевірки антивірусних компонентів
    Нині існують такі основні критерії тестування:
        Індикатор виявлення вірусної бази;
        Індикатор виявлення, за списком «in wild»;
        Ряд фальшивих операцій;
        Еристичний аналіз;
        Процес емуляції;
        Лікувальний інфікований компонент.
    Індикатор виявлення вірусної бази означає, що в процесі тестування вона виконує сканування за запитом, з великою кількістю заражених типів. Рівень зараження безпосередньо вимірюється у відсотковому відношенні кількості заражених компонентів до загальної кількості перевірених файлів.
    Індикатор виявлення за списком «in wild» означає тестування файлів і компонентів із зазначеного списку ITW. Він вимірюється відсотком знайдених шкідливих програм щодо загальної кількості об’єктів.
    Велика кількість підроблених операцій означає, що тест використовує велику кількість можливих файлів, які насправді не є небезпечними. Тестування вимірює кількість фальшивих операцій із загальною кількістю елементів.
    Еристичний аналіз – це спеціальний метод, повністю заснований на сигнатурах і еристики, який дозволяє ефективно знаходити модифіковані версії вірусів, коли сигнатура не повністю збігається з тілом невідомої утиліти, а підозріла програма має всі ознаки вірусного компонента.
    До речі, ця технологія рідко використовується в сучасних тестах, оскільки може легко збільшити відсоток фальшивих операцій під час тестування.
    Емулятор – це масштабне тестування компонента за допомогою сканера сигнатур за підозрою, що він містить елемент шкідливого ПЗ.
    Лікування – це метод визначення можливостей антивірусних компонентів «лікувати» об’єкти, коли шкідливе середовище досягло файлів користувача та активно протидіє його прямому видаленню.
    Підсумовуючи, можна зробити чіткий висновок, що сьогодні не існує 100% ефективного програмного компонента, який повністю швидко та безпосередньо «вбиває та знищує» шкідливі компоненти та дані.
    Але повне розуміння можливих небезпек і правильний вибір методів антивірусного захисту може допомогти значно знизити рівень можливого зараження та правильно побудувати процес тестування та аналізу того чи іншого компонента захисту. Це означає, що ваша команда із забезпечення якості повинна відповідально підходити до тестування антивірусних компонентів і з чітким розумінням виконуваних дій.
    
        Розроблення системи запобігання атак на основі аналізу мережевого трафіку при роботі з операційною системою
    Прийняття рішень у випадку роботи системи по запобіганню вторгнення мережевих атак (система IDS) здійснюється в умовах апріорної невизначеності, обумовленої неточністю або неповнотою вхідних даних, стохастичною природою зовнішніх впливів, відсутністю адекватної математичної моделі функціонування, нечіткістю мети, людським фактором та ін. Невизначеність системи призводить до зростання ризиків від прийняття неефективних рішень, результатом чого можуть бути негативні економічні, технічні та соціальні наслідки. У проекті були використані основні принципи нечіткої логіки, які базуються на трьох рівнях захисту. Вимоги до них описані нижче.
        Низький (Low):
        заборона запуску деяких програм зі списку користувача
        заборона одного з видів пакетів
        закриття портів, які вищі за 1024
        Середній (Medium):
        заборона запуску всіх чатів (закрити всю мережеву активність)
        заборона всіх пакетів, крім TCP / IP
        закриття всіх портів, крім 80, 8080, 8081, 2323, 443, 4433
        Високий (High):
        закриття всіх портів, крім 80 і 8080
        заборона запуску всіх програм, окрім Хрома.
        заборона всіх пакетів, крім TCP / IP
    
        Математичні основи представлення результатів
    Кожен із рівнів захисту виконує блокування тої чи іншої атаки. Звісно ж, що частина задачі для кожного з трьох рівнів є спільною, оскільки існує багато чинників, які впливають на ту чи іншу реакцію IDS. Схематично можна представити лінгвістичну змінну на рис. 3.3:
     
    Рис.3.3. Лінгвістична змінна, яка відповідає за рівні захисту 
    та припинення атак IDS системи
    
    Можливі керуючі рішення щодо вторгнення обмежені в залежності від конкретної ситуації трьома керуючими елементами, які показані вище на рис. 3.3. Неперервні кусково-лінійні апроксимовані функції описують нечітку множину станів системи IDS.
    Для кожного терму «Low», «Medium», «High» лінгвістичної змінної є відповідна реакція системи. 
    
        Логічні змінні, які беруть участь в аналізі даних трафіку
    На підставі поставленої задачі безпеки складається наступна система: 
    1) якщо лінгвістична змінна має значення «Low», то ступеня переваги керуючих рішень складають:
    a(Low)=1; a (Medium)=0,5; a(High)=0;
    2) якщо значення лінгвістичної змінної «Medium», то 
    a(Low)=0,5; a(Medium)=1; a(High)=0,5;
    3) якщо лінгвістична змінна має значення «High», то 
    a(Low) =0; a(Medium)=0,5; a(High)=1.
    При цьому ступінь переваги кожного виду керуючого рішення в конкретній ситуації визначається як кон'юнкція ступеня застосування того чи іншого правила і заданих в них ступенів переваги керуючих рішень. Результуючі ступеня переваги застосування керуючих рішень приймаються рівними максимальним серед відповідних ступенів переваги по кожному значенню ознак «Low», «Medium», «High».
    
        Опис інтерфейсу розробленої системи IDS
    Реалізація IDS системи виконана у середовищі Visual Studio Professional 2015. 
     
    Рис.3.4. Стартова сторінка середовища Visual Studio Pro
    У режимі конструктора було продумано інтерфейс стартового вікна системи, яке зображено на рис. 3.5.
     
    Рис. 3.5. Розробка стартової форми у режимі конструктора
    
    Система має досить зручний у користуванні інтерфейс. Запуск програми починається із анімованого стартового вікна, яка зображено на рис. 3.6.
     
    Рис. 3.6. Стартове вікно розробленої IDS
    
    Для розробки даного було створено програмний код з відповідною послідовністю.
        Підключення потрібних бібліотек для роботи з формою:
    using System;
    using System.Windows;
    
        Створення класу, який містить всі об’єкти стартової форми:
    namespace WindowsApplication1
    {
        public partial class startWin : Win
        {
            int count = 0;
            string[] ports = SerialPort.GetPortNames();
            string s = "";
            public startWin()
            {
                InitializeComponent();
            }
    
            private void timer1_Tick(object sender, EventArgs e)
            {            
                count++;
                if ((count < 100) && (Opacity < 1))
                {
                    Opacity += 0.01;
                    progressBar1.Value = 100;
                }
                else if ((count > 200) && (Opacity>0))
                {
                    Opacity -= 0.01;   
                }
                else if (count == 300)
                {
                    timer1.Enabled = false;
                    functionalWin fm = new functionalWin();
                    Hide();
                    fm.Show();
                }                
            }
        }
    }
    
    Слід також відмітити, що при створені анімації у формі, було використано об’єкт timer. Останній дає можливість обробляти динамічно ті, чи інші події, які відбуваються під час роботи програми.
    Саме функція timer1_Tick відповідає за процес обробки даних, у даному випадку анімацій. 
    Наступний фрагмент коду програми відповідає за появлення форми на екран:
    if ((count < 100) && (Opacity < 1))
        {
            Opacity += 0.01;
            progressBar1.Value = 100;
        }
    Нижченаведений фрагмент коду дає можливість зменшувати прозорість форми перед її закриттям:
    if ((count > 200) && (Opacity>0))
    {
       Opacity -= 0.01;   
    }
    Наступний фрагмент коду дає можливість закрити поточну форму та перейти до форму з основним функціоналом програми (системи IDS):
    if (count == 300)
    {
       timer1.Enabled = false;
       functionalWin fm = new functionalWin();
       Hide();
       fm.Show();
    }
    Інтерфейс головного вікна програми зображений на рис. 3.7.
     
    Рис. 3.7. Розробка інтерфейсу головного функціоналу IDS у режимі конструктора
    
    Слід такого відмітити, що при розробці подібних програм потрібно використовувати різні системні бібліотеки, за допомогою яких можна отримати різні характеристики комп’ютера, його складових, всіх процесів, потоків, протоколів тощо. Один з таких об’єктів, за допомогою якого можна отримати потрібні дані, називається PerformanceCounter. Він знаходиться у панелі інструментів конструктора (рис. 3.8).
     
    Рис. 3.8. Основні інструменти режиму конструктора
    Після того, як була закрита перша (стартова) форма, відкривається друга форма, яка фактично містить основні налаштування системи та основний функціонал.
     
    Рис. 3.9. Інтерфейс основної програми. Демонстрація основного її функціоналу
    
    На рис. 3.9 видно три графіки. Кожен з них отримується за допомогою підключення до відповідного Wi-FI адаптера. Якщо такого адаптера немає або він просто відключений, то графіків не буде, оскільки всі дані отримуються по WI-FI.
    Тепер перейдемо до опису самого функціоналу розробленої системи. Для отримання кількості прийнятих та відправлених пакетів було створено наступний код програми:
    private void timer1_Tick(object sender, EventArgs e)
            {
                try
                {
                    pC1.InstanceName = comboBox1.Text.ToString();
                    pC2.InstanceName = comboBox1.Text.ToString();
                    pC3.InstanceName = comboBox1.Text.ToString();
    
                    Y1_data.Add(pC1.NextValue());
                    Y2_data.Add(pC2.NextValue());
                    Y3_data.Add(pC3.NextValue());
    
                    if (Y2_data.Count > 60)
                    {
                        Y1_data.RemoveAt(0);
                        Y2_data.RemoveAt(0);
                        Y3_data.RemoveAt(0);
                    }
    
                    chart1.Series["Series1"].Points.DataBindY(Y1_data);
                    chart2.Series["Series1"].Points.DataBindY(Y2_data);
                    chart3.Series["Series1"].Points.DataBindY(Y3_data);
                }
                catch { }
            }
    
    Звісно ж, перед тим, як використовувати даний код, вважається, що всі елементи та об’єкти форми вже є налаштовані і всі дані отримуються коректно. Для відображення графіків було використано об’єкт chart. Налаштування об’єкту chart було виконано теж у режимі конструктора. Це дає змогу зменшити написання самого коду при роботі з даним об’єктом.
    Для закриття додатків, які обрані користувачем було написано метод:
    private void for_pros_Tick(object sender, EventArgs e)
            {
                if (flag1 == true)
                {
    На даному етапі виконується пошук додатку Skype, після чого виконується його закриття.
    Process[] ps1 = System.Diagnostics.Process.GetProcessesByName("skype");
                    foreach (Process p1 in ps1)
                        try { p1.Kill(); }
                        catch { }
    На даному етапі виконується пошук додатку Viber, після чого виконується його закриття.
    Process[] ps2 = System.Diagnostics.Process.GetProcessesByName("Viber.Universal");
    
    foreach (Process p1 in ps2)
         try { p1.Kill(); }
         catch { }
    На даному етапі виконується пошук додатку TeamViewer, після чого виконується його закриття.
    Process[] ps3 = System.Diagnostics.Process.GetProcessesByName("TeamViewer");
    
        foreach (Process p1 in ps3)
           try { p1.Kill(); }
           catch { }
    На даному етапі виконується пошук додатку Explorer, після чого виконується його закриття.
    Process[] ps4 = System.Diagnostics.Process.GetProcessesByName("iexplore");
    
        foreach (Process p1 in ps4)
           try { p1.Kill(); }
           catch { }
    На даному етапі виконується пошук додатку Camera, після чого виконується його закриття.
        Process[] ps5 = System.Diagnostics.Process.GetProcessesByName("WindowsCamera");
    
        foreach (Process p1 in ps5)
        try { p1.Kill(); }
        catch { }
    
      }
    }
    Даний фрагмент програми закриває активні процеси з відповідними додатками, після чого їм можна знову запустити тільки в тому випадку, якщо буде обрано інший рівень захисту та перешкод вторгнень.
    Тепер перейдемо до самих рівнів захисту від вторгнень. Для того, щоб перемикати рівні, було створено три функції:
    private void High_Click(object sender, EventArgs e)
            {
                flag1 = flag2 = false;
                flag3 = true;
            }
    
            private void Low_Click(object sender, EventArgs e)
            {
                flag2 = flag3 = false;
                flag1 = true;
            }
    
            private void Medium_Click(object sender,EventArgs e)
            {
                flag1 = flag3 = false;
                flag2 = true;
            }
    
    Виходячи з назв самих функцій, очевидно, яка з них і що виконує. Якщо обрано один рівень захисту (а може бути обрано тільки один з трьох), то інші рівні автоматично вимикаються. Цей процес описано за допомогою трьох булевих змінних. З їх допомогою можна вмикати та вимикати відповідні рівні захисту.
    Наступна функція дає змогу вимкнути всі рівні захисту, якщо це потрібно.
    private void Off_Click(object sender, EventArgs e)
            {
                flag1 = flag2 = flag3 = false;
            }
    Звісно ж, що така функція потрібно, оскільки вторгнення відбуваються не завжди, тому весь час себе теж не потрібно обмежувати при роботі з ПК. Рядок
    flag1 = flag2 = flag3 = false;
    означає, що всі рівні захисту вимкнені.
    Кожен рівень захисту має свої особливості як і з точки зору реалізації, так і з точки зору захисту. Перший рівень захисту (Low) він передбачає, що буде припинена робота наступних програм користувача: Skype, TeamViewer, Viber.
    Програми не можна увімкнути знову, коли стоїть відповідний рівень захисту. Всі зміни, а саме, закриття тих чи інших процесів, потоків, пакетів чи протоколів відображаються у протоколі, який наведено на рис.7.
     
    Рис. 3.10 – Протокол, зі звітуванням змін та захисту ПК
    Слід також відмітити, що перегляд журналу подія можливий у будь-який час. Його виклик виконується з форми з функціоналом IDS системи.
    На рис. 3.11 вказана відповідна інформація.
    
     
    Рис. 3.11. Основні системні вимоги до операційних систем, 
    на яких може працювати розроблена IDS система
    Висновки до третього розділу
    У ході виконання дипломної роботи було проаналізовано сучасний стан ефективності застосування штучного інтелекту для аналізу антивірусних систем. Штучний інтелект може допомогти підвищити їх ефективність та точність виявлення загроз. Однак, він не є універсальним рішенням для всіх проблем у галузі кібербезпеки та потребує професійного підходу до його застосування.
    Машинне навчання фокусується на розробці комп’ютерних програм, які можуть отримувати доступ до даних і використовувати їх для самостійного навчання. Процес навчання починається з перегляду даних, наприклад, конкретного досвіду або інструкцій, аналізу шаблонів даних і прийняття кращих рішень на основі наданих нами стандартів. Основна мета — дозволити комп’ютерам навчатися автоматично без втручання людини та правильних дій.
    У комп'ютерних мережах найважливіше – безпека мережі. Люди добре організовують безпеку, але люди більш схильні до помилок, ніж машини, тому обладнання можна навчити забезпечувати та покращувати безпеку мереж.
     
    ВИСНОВКИ
    На основі аналізу сучасних методів штучного інтелекту розроблено програмний засіб аналізу мережевого трафіку та прогнозу ефективності передачі даних через локальну та глобальну мережі.
    Аналіз антивірусних систем методами штучного інтелекту (ШІ) може бути проведений у кількох напрямках.
        Аналіз поведінки програм. Багато сучасних антивірусних систем використовують методи машинного навчання та аналізу поведінки програм для визначення, чи є програма шкідливою. Це дозволяє виявляти нові загрози, які раніше не були відомі та не були включені до бази даних вірусів.
        Аналіз сигнатур вірусів. Антивірусні системи використовують базу даних сигнатур вірусів визначення, чи файл шкідливим. Використання методів машинного навчання та ІІ може допомогти покращити точність виявлення вірусів та скоротити кількість помилкових спрацьовувань.
        Аналіз віртуальних середовищ. Віртуальні середовища можуть бути використані для ізоляції шкідливих програм та аналізу їхньої поведінки без ризику зараження основної системи. Використання методів ІІ для аналізу даних, отриманих в результаті роботи віртуальних середовищ, може допомогти виявити нові загрози та скоротити час на їх виявлення.
        Аналіз потоку даних. Методи машинного навчання та ІІ можуть бути використані для аналізу потоку даних у мережі, щоб виявляти аномальні події та запобігати атакам.
     
    СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ
        Expertsystem.com. (2017). What is Machine Learning? A definition - Expert System. Режим доступу: https://www.expertsystem.com/machine-learning-definition.
        Apiumhub. (2016). Applications of machine learning in cybersecurity. Режим доступу: https://apiumhub.com/tech-blog-barcelona/applications-machine-learning-cyber-security.
        Rahul Reddy Nadikattu, "THE EMERGING ROLE OF ARTIFICIAL INTELLIGENCE IN MODERN SOCIETY", International Journal of Creative Research Thoughts (IJCRT), ISSN:2320- 2882, Volume.4, Issue 4, pp.906-911, December 2016, Режим доступу: http://www.ijcrt.org/papers/IJCRT1133435.pdf.
        Business Security Insider Blog by F-Secure | Cyber Security News, Articles & Tips. (2018).
        Apiumhub. (2017). Applications of machine learning in cybersecurity. Режим доступу: https://apiumhub.com/tech-blog-barcelona/applications-machine-learning-cyber-security.
        Suomalainen, J., Juhola, A., Shahabuddin, S., Mammela, A., & Ahmad, I. (2020). Machine Learning Threatens 5G Security. IEEE Access, 8, 190822–190842. https://doi.org/10.1109/access.2020.3031966.
        Wang, B. (2018, February 14). Stealing Hyperparameters in Machine Learning. ArXiv.Org. Режим доступу: https://arxiv.org/abs/1802.05351.
        Xue, M., Yuan, C., Wu, H., Zhang, Y., & Liu, W. (2020). Machine Learning Security: Threats, Countermeasures, and Evaluations. IEEE Access, 8, 74720–74742. Режим доступу: https://doi.org/10.1109/access.2020.2987435.
        Zhang, J., & Li, C. (2019). Adversarial Examples: Opportunities and Challenges. IEEE Transactions on Neural Networks and Learning Systems, 1–16. Режим доступу: https://doi.org/10.1109/tnnls.2019.2933524.
        Zhang, Z., Yang, X., & Huang, K. (2021). Attacking Sequential Learning Models with Style Transfer Based Adversarial Examples. Journal of Physics: Conference Series, 1880(1), 012021. Режим доступу: https://doi.org/10.1088/1742-6596/1880/1/012021.
    </p>
